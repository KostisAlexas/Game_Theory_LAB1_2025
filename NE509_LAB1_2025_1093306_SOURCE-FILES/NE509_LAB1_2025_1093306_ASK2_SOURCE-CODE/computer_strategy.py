import random

BOARD_SIZE = 8

# Λεξικό με τους αριθμούς Grundy για κάθε κελί της σκακιέρας (8x8)
# Κάθε κλειδί αποτελείται από το νούμερο γραμμής (0 έως 7) και το γράμμα στήλης (a έως h).
# Οι τιμές είναι οι αντίστοιχοι αριθμοί Grundy (π.χ. "*0", "*1", "*2").
# Why calculate it when you can hardcode it.
grundy_dict = {"0a":"*0", "0b":"*0", "0c":"*0", "0d":"*0", "0e":"*0", "0f":"*0", "0g":"*0", "0h":"*0",
               "1a":"*0", "1b":"*0", "1c":"*1", "1d":"*1", "1e":"*1", "1f":"*1", "1g":"*1", "1h":"*1", 
               "2a":"*0", "2b":"*1", "2c":"*1", "2d":"*1", "2e":"*2", "2f":"*2", "2g":"*2", "2h":"*2", 
               "3a":"*0", "3b":"*1", "3c":"*1", "3d":"*0", "3e":"*0", "3f":"*0", "3g":"*0", "3h":"*0", 
               "4a":"*0", "4b":"*1", "4c":"*2", "4d":"*0", "4e":"*0", "4f":"*1", "4g":"*1", "4h":"*1", 
               "5a":"*0", "5b":"*1", "5c":"*2", "5d":"*0", "5e":"*1", "5f":"*1", "5g":"*1", "5h":"*2", 
               "6a":"*0", "6b":"*1", "6c":"*2", "6d":"*0", "6e":"*1", "6f":"*1", "6g":"*0", "6h":"*0", 
               "7a":"*0", "7b":"*1", "7c":"*2", "7d":"*0", "7e":"*1", "7f":"*2", "7g":"*0", "7h":"*0"}


def get_optimal_move(knight_pos):
    """
    Υπολογίζει την καλύτερη κίνηση για τον υπολογιστή βάσει της στρατηγικής Sprague-Grundy.

    Παράμετροι:
    knight_pos -- το τρέχον κελί του ίππου ως tuple (στήλη, γραμμή), με βάση το 0-index.

    Επιστρέφει:
    Το νέο κελί (στήλη, γραμμή) που θα μετακινηθεί ο ίππος ή None αν δεν υπάρχουν επιτρεπτές κινήσεις.
    """
    col, row = knight_pos
    # Ορισμός των δύο δυνατών κινήσεων του ίππου:
    possible_moves = [(col - 2, row - 1), (col - 1, row - 2)]
    valid_moves = []

    # Ελέγχουμε κάθε πιθανή κίνηση για να διασφαλίσουμε ότι παραμένει εντός των ορίων της σκακιέρας
    # και ότι οδηγεί σε μικρότερη στήλη και γραμμή από την αρχική θέση.
    for move in possible_moves:
        c, r = move
        if 0 <= c < BOARD_SIZE and 0 <= r < BOARD_SIZE and (c < col and r < row):
            valid_moves.append(move)

    # Αν δεν υπάρχουν έγκυρες κινήσεις, τότε επιστρέφουμε None.
    if not valid_moves:
        return None

    # Δημιουργούμε μια λίστα με τα ζεύγη (κίνηση, αριθμός Grundy) για κάθε έγκυρη κίνηση.
    # Μετατρέπουμε το συντεταγμένο κελιού στον τύπο "γραμμή + στήλη" (π.χ., "2f" για γραμμή 2, στήλη f)
    columns = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
    moves_with_grundy = []
    for move in valid_moves:
        c, r = move
        key = f"{r}{columns[c]}"
        grundy = grundy_dict.get(key)
        moves_with_grundy.append((move, grundy))

    # Αναζήτηση κινήσεων που οδηγούν σε θέση με Grundy "*0".
    # Αυτές οι κινήσεις είναι προτιμότερες, καθώς μεταφέρουν στον αντίπαλο θέση ήττας.
    zero_moves = [move for move, g in moves_with_grundy if g == "*0"]

    # Αν υπάρχει τουλάχιστον μία κίνηση με Grundy "*0", επιλέγουμε τυχαία μία από αυτές.
    if zero_moves:
        return random.choice(zero_moves)
    else:
        # Εάν καμία κίνηση δεν οδηγεί σε "*0", τότε επιλέγουμε τυχαία από τις έγκυρες κινήσεις.
        return random.choice(valid_moves)


# Για λόγους συμβατότητας με το προηγούμενο interface, μπορούμε να ορίσουμε και μια συνάρτηση
# get_random_move που απλά καλεί την get_optimal_move. Σε περίπτωση που η στρατηγική δεν
# εφαρμοστεί πλήρως ή για δοκιμαστικούς λόγους, αυτή η συνάρτηση θα μπορούσε να επιστρέφει
# και τυχαία κίνηση. Εδώ όμως επιλέγουμε πάντα την καλύτερη κίνηση.
def get_random_move(knight_pos, allowed_moves=None):
    return get_optimal_move(knight_pos)